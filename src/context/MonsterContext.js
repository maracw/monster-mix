import createDataContext from './createDataContext';
import * as SecureStore from 'expo-secure-store';
import { bottomMonsterParts, midMonsterParts, topMonsterParts } from "../data/monsterPartList";

async function save(key, value) {
  try {
    const jsonValue = JSON.stringify(value);
    await SecureStore.setItemAsync(key, jsonValue);
  } catch (error) {
    console.error('Error saving value to SecureStore:', error);
  }
}
const fetchData = async () => {
  try {
    SecureStore.clear();
    const savedData = await SecureStore.getItemAsync('monsters');
    
  
    if (savedData) {
      const parsedData = JSON.parse(savedData);
      dispatch({ type: 'set_monsters', payload: parsedData });
    } else {
      dispatch({ type: 'set_monsters', payload: [] });
    }
  
 
  } catch (error) {
    console.error('Error retrieving app data from SecureStore:', error);
  }
};
const monsterReducer = (state, action) => {
  switch (action.type) {
   
    //set the array of monster objects
    case 'set_monsters':
      return action.payload;
      
    //edit single monster object
    case 'edit_monster':
      newState = state.map((monster) => {
        let match = monster.id===action.payload.editedMonster.id? true: false;
        let returnMonster=monster;
       if(match){
        returnMonster = action.payload.editedMonster;
       }
        return returnMonster;
      });
      save("monsters", newState);
      return newState;
    case 'delete_monster':
      newState = state.filter((monster) => monster.id !== action.payload);
      save("monsters", newState);
      return newState;
    case 'add_monster':
      newState = [
        ...state,
        //monster properties
        {
          //id: Math.floor(Math.random() * 99999),
          //id now generated by create form
          id: action.payload.monsterToSave.id,
          madeBy: action.payload.monsterToSave.madeBy,
          monsterName: action.payload.monsterToSave.monsterName,
          monsterType: action.payload.monsterToSave.monsterType,
          top: action.payload.monsterToSave.top, 
          mid: action.payload.monsterToSave.mid, 
          bottom: action.payload.monsterToSave.bottom,
        },
      ];
      save("monsters", newState);
      return newState;
    default:
      return state;
  }
};

const addMonster = (dispatch) => {
  return (monsterToSave, callback) => {
    //callback is navigation
    dispatch({ type: 'add_monster', payload: { monsterToSave } });
    if (callback) {
      callback();
    }
  };
};

const deleteMonster = (dispatch) => {
  return (id) => {
    dispatch({ type: 'delete_monster', payload: id });
  };
};

const editMonster = (dispatch) => {
  
  return (editedMonster, callback) => {
    dispatch({
      type: 'edit_monster',
      payload: { editedMonster },
    });
    if (callback) {
      callback();
    }
  };
};

export const { Context, Provider } = createDataContext(
  monsterReducer,
  { addMonster, deleteMonster, editMonster },
  []
);
